---
author: 'mpi'
title: 'Bitemporal TraderX - XTDB Reflections'
description: 'Using XTDB in a sample microservices trading application for the FINOS 2024 Tech Sprint (part 2)'
category: 'database'
layout: '../../layouts/BlogPost.astro'
publishedDate: '2025-02-03'
heroImage: 'bitemporal-traderx2.jpg'
tags:
  - 'SQL'
  - 'database'
  - 'XTDB'
  - 'FINOS'
---

import { Image } from 'astro:assets'

In the [previous blog post](/blog/bitemporal-traderx/) on this topic I wrote about my work as a lead engineer on a small team taking part in the [FINOS](https://www.finos.org/) 2024 Tech Sprint - a multi-week hackathon centered around the [TraderX](https://github.com/finos/traderx) project, which is essentially an example system (think ’Pet Store’) that is intended purely for educational and training purposes. TraderX was initially developed by Morgan Stanley.

In this follow-up post I will share some thoughts about [XTDB](https://xtdb.com) (a 'bitemporal' database created by JUXT) and discuss a few potential future directions for the codebase. As a recap, this was a short video we put together which gives an overview of the system and some of the changes we made:

<iframe class='aspect-video w-full' src="https://www.youtube.com/embed/d_o6Dy3I2r8?si=huuab9Qxb_8Hmqs1" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## First Impressions

This was my first time using XTDB so I had some learning to do. Being a SQL database, most things about XTDB felt quite familiar but it still takes a little time to get used to the temporal syntax (at least you only have to learn it once!).
After studying the existing TraderX data model and reading the project brief my instinctive reaction was to start adding dedicated columns to the applicaiton's schema for handling various application and auditing timestamps like `traded_at` and `updated_at` - but what a pleasant surprise it was to find out there’s little need for many of these kinds of columns in XTDB - timestamping is already ubiquitous and all done under the covers.

The biggest surprise however was that because of this built-in functionality, *compared to using a traditional SQL database for recording changes and keeping old versions around, how you interact with an XTDB database remains intuitive* - at least until you need to retrieve the historical data or introduce 'retroactive' updates (e.g. when you discover some data was incorrect in the past and want to set the record straight with a correction, or when you want to backfill some data). Essentially you can very simply use INSERT, UPDATE and DELETE statements to mutate and edit data as normal, yet you are also left with a perfectly auditable history where you can see all changes across all records.

Wait - what? History? Yes! You get all the change history for free! - not just what changed when - but you can inspect all those historical values. For example, UPDATE statements in XTDB don’t actually overwrite old values - instead they create new entries that are carefully tracked across two time lines - 'valid time' (otherwise known as 'application time') and system time (what you can think of as wall-clock time).

The way the XTDB team have extended the 'normal' update-in-place semantics of SQL is very straightforward and reassuring to work with. You can insert data, change it, see the current state based on those changes (i.e. historical states are filtered away by default), but then always go back and see how the data looked previously. This combined with the rich flexibility of SQL and the confidence that you don't need to worry about irretrievably breaking the data itself - or any concurrent users of the data history, such as reporting applications - is an attractive proposition.

### Integrating Sliders

import sliders from '../../assets/blog/bitemporal-traderx.png'

<Image style="width: 100%; margin-left: auto; margin-right: auto" alt='View of TraderX showing SQL overlayed' src={sliders} />

Adding temporal 'sliders' to the TraderX UI was an easy way to expose the time-travel abilities of XTDB, and makes it far more efficient for users of the various blotters and dashboards to quickly observe and scrub through the changing data, compared to having to click on some calendar widget to navigate through the history. This is a great way to understand the value that the bitemporal model can bring: just imagine any existing application with a time slider and how useful that could be for the end user - especially in domains where the end user is making important decisions based on the changing data.

Implementing the change required getting data from a couple of joined tables ‘as of’ a certain point in time, which entails a small amount of ceremony, particularly if you want to be able to control specific `valid time` or `system time` views for each table independently. Otherwise though, if you don't need any finer grained control, you can set the as-of time for the entire query easily enough.

It also took me a couple iterations to get correct timeline markers displayed for the ‘event’ slider, which consolidates the history from across all know versions of trades - and therefore corresponds to various changing moments in time when positions changes.

My initial thought was to naively query for a collection of time periods, with the period start being `_valid_from` and period end being `_valid_to`, for all trades in ascending order - but this was no good as the periods would all be interleaved across the unrelated trades. Instead, what I actually ended up with was a slider where all the points are purely `_valid_from` values for all trades (and there’s no restriction on `_valid_to`). This resulted in a clear history of trades and their lifecycle - from their creation in pending state to settlement.

In addition to the main blotter slider I also added a price slider. This was much easier, essentially a basic view of price ‘as of’ some given day, using regular daily steps. The blotter query then effortlessly joins across these two underlying table sources using their respective as-of timestamps.

## Takeaway Opinions

I have worked on several applications that incorporate reporting requirements previously, and I can safely say XTDB brings a lot of benefits over the traditional SQL database paradigm.

**Having automatic bitemporal versioning unlocks powerful reporting capabilities** - not only over past changes, but also opening the door to speculative analysis (e.g. "what would my account PnL look like with prices from a given day in the past" / "how much could I have gained/lost if I had bought stock X on date Y"). All without requiring planning ahead or thinking about separate versioning requirements in each part of the schema.

**A first-class history close to hand is a game changer in terms of application development** - a whole range of time related complexities are taken care of by the bitemporal model and XTDB makes working with bitemporal data very easy. You could compare it to what happened when you could relegate transaction management from application logic into the database layer. There is a little bit to learn about in order to start using [SQL:2011](https://en.wikipedia.org/wiki/SQL:2011)’s temporal operators - but this is really nothing compared to benefits you get from just using it.

**XTDB provides bitemporal storage with virtually no barrier to entry** - [DML](https://en.wikipedia.org/wiki/Data_manipulation_language) (SQL statements for storing / updating entities) simply inserts new rows and does not change existing data, while the retrieval of historical data is trivial using SQL:2011 queries (leveraging ‘FOR VALID TIME’ to get a point/period in the past). The only caveat in this project was that XTDB doesn't yet fully work with JPA style persistence due to minor differences with real Postgres, but working with plain SQL or simpler abstractions (e.g. [jOOQ](/blog/15-years-of-jooq-with-lukas-eder/)) is my preference anyway.

**No more need for bespoke audit tables** or manual addition of more timestamped fields (such as ‘updated_at’) - history is transparently preserved along with the two timelines - system time and valid time. There is even a built-in transaction log table that shows all the transactions and their timestamps.

**XTDB drastically reduces complexity** otherwise introduced by hand-rolled reporting solutions - these usually come in later as post production release requirements (dictated by reporting/auditing/legal needs).
You’re free to focus on adding competitive value to your application - unique features that will set you out from your competition - without expending time and effort on 'custom' versioning capabilities which, whilst often absolutely required, do not necessarily give end users visible benefit.

## Ideas for the future

If XTDB can add complete support for JPA style annotations, then XTDB could fully replace the use of the [H2](https://www.h2database.com/html/main.html) database within the TraderX repo, without any code changes. In a future Tech Sprint we may consider attempting this, and also adding additional reporting functionality (e.g. predicted vs. actual comparisons).

It would also be interesting to expand TraderX with semi-structured data (e.g. email data, or Risk data) and similarly demonstrate how XTDB is well-suited for handling evolving schemas over time whilst also providing ACID transactions and without resorting to JSON serializations.

## The XTDB team are looking for Design Partners

JUXT is currently collaborating with several Design Partners using XTDB who help us discover missing features - we cannot responsibly take on too many partners (as we do need to support those features!), but if you feel like XTDB is the right fit for your problem, please do get in touch: [hello@xtdb.com](mailto://hello@xtdb.com)
