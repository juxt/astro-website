---
author: 'osm'
layout: '../../layouts/BlogPost.astro'
title: 'Calling AWS Lambda over HTTP'
description: 'Everything You Need to Know About Calling AWS Lambda over HTTP: Setup, Formats, and Error Handling Explained'
category: 'architecture'
publishedDate: '2024-06-11'
tags:
  - http
  - aws
  - lambda
  - 'api gateway'
  - cloudfront
heroImage: 'xt24-stage.jpg'
---

{/*

The requirement that this blog post fulfils is:
As a developer, I want to know:
- What different ways are there I can call a lambda over HTTP
- For each of those:
  - What is the formats of requests and responses?
  - What happens if the request/response is in the wrong format?
  - What happens if exceptions are thrown?
  - What other quirks are there?
And I want to have it all in one place.

*/}

There are two different methods to call an AWS Lambda over HTTP externally:
[Function URLs](https://docs.aws.amazon.com/lambda/latest/dg/lambda-urls.html)
and [API Gateway](https://aws.amazon.com/api-gateway/)

But as I investigated, I found each had slightly different behaviours, quirks
and setup instructions. I ended up with 20+ tabs open and writing a bunch of
test cases, so I thought I would share what I had learned all in one place.



## Methodology

While reading, the questions tried to answer were:
1. How do I set this up?
2. What are the input and output formats?
3. What happens if I don't use these formats?
4. What happens if an exception is thrown?
5. What other quirks are there?

For the most part I can link you to the relevant part of the docs, but for
some I needed to run some tests. The tests I ran were:

| Test                  | Command                                                                |
| ---                   | ---                                                                    |
| Valid JSON request    | `curl -v -XPOST --data '{}' <url under test>`                          |
| Invalid JSON request  | `curl -v -XPOST --data '{'  <url under test>`                          |
| Valid JSON response   | Covered by that first test                                             |
| Invalid JSON response | `curl -v -XPOST --data '{}' --header 'Test: invalid' <url under test>` |
| Exception thrown      | `curl -v -XPOST --data '{}' --header 'Test: error'   <url under test>` |

And the code I used to setup the lambda was:
  
```clojure
(ns lambda
  (:gen-class
   :implements [com.amazonaws.services.lambda.runtime.RequestStreamHandler]))

(defn -handleRequest [_ is os context]
  (let [input (slurp is)]
    (println "input:" input)
    ; If the word "error" is found in the input
    (when (re-find #"error" input)
      (throw (ex-info "test" {:my "error"})))
    ; If the word "invalid" is found in the input
    (if (re-find #"invalid" input)
      (spit os "{")
      (spit os "{}"))))
```

(See my [last post](https://juxt.pro/blog/plain-clojure-lambda) for how I set
the project up)

Please note that the input is *not parsed*, so any errors that come parsing
the input must come from AWS. Also note that the output does not conform to
any of the formats required, this tests how each option behaves in this case.

There are multiple ways to setup each option, I cover these methods:
- [Plain Function URLs](#plain-function-urls)
- [Function URLs + CloudFront](#function-urls--cloudfront)
- [API Gateway w/ HTTP API](#api-gateway-w-http-api)
- [API Gateway w/ REST API](#api-gateway-w-rest-api)
- [API Gateway w/ REST API & Lambda Proxy Integration](#api-gateway-w-rest-api--lambda-proxy-integration)



## Which should you choose?

Before we start, this article doesn't aim to judge which option of these fits
your requirements. If you're wanting a quick judgement for which to check out
first my preferences are:
- If you don't want a custom domain: [Plain Function URLs](#plain-function-urls)
- If you *do* want a custom domain: [Function URLs + CloudFront](#function-urls--cloudfront)
- For everything else I'd suggest: [API Gateway w/ REST & Lambda Proxy Integration](#api-gateway-w-rest-api--lambda-proxy-integration)



## Plain Function URLs

This is by far the easiest option to setup: [just enable it and set two
settings](https://docs.aws.amazon.com/lambda/latest/dg/urls-configuration.html#create-url-console)
and you're done!

The (small) downside is that you get a randomly generated url of the form:
`https://<url-id>.lambda-url.<region>.on.aws`. For many use cases this is just
fine.

As with most of these options, the [request](https://docs.aws.amazon.com/lambda/latest/dg/urls-invocation.html#urls-request-payload)
and [response](https://docs.aws.amazon.com/lambda/latest/dg/urls-invocation.html#urls-response-payload)
formats are in JSON. Particularly worth noting is if the response *does not*
match this format then a 200 response is assumed.

Here are the results of my tests:

| Test                  | Status Code | Response Body           | `input` in lambda          |
| ---                   | ---         | ---                     | ---                        |
| Valid JSON request    | 200         | `{}`                    | The JSON formatted request |
| Invalid JSON request  | 200         | `{}`                    | The JSON formatted request |
| Invalid JSON response | 200         | `{`                     | The JSON formatted request |
| Exception thrown      | 502         | `Internal Server Error` | The JSON formatted request |



## Function URLs + CloudFront

This option allows you to create a [TLD](https://en.wikipedia.org/wiki/Top-level_domain)
that points at your Lambda Function URL. The behaviour mostly identical to
Function URLs but I have included it because of one "gotcha" in the setup that
can change the behaviour.

The setup is:
- [Create a Function URL](https://docs.aws.amazon.com/lambda/latest/dg/urls-configuration.html#create-url-console) 
(same as above)
- [Create your CloudFront Distribution](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-creating-console.html)
  - For **origin domain** choose your **Function URL**
  - For **Allowed HTTP methods** choose all the methods you plan to use (this is the "gotcha" I mentioned)
  - For **Alternate domain name** choose the TLD you want
  - For **Custom SSL certificate** choose a certificate for the TLD you chose
  - For a simple setup you can disable caching and the WAF
- [Add an A record to Route53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-creating.html)
  - Use an alias to point to your Distribution's URL
- Wait until the CloudFront Distribution has finished deploying

As mentioned, this option uses Function URLs under the hood so the [request](https://docs.aws.amazon.com/lambda/latest/dg/urls-invocation.html#urls-request-payload)
and [response](https://docs.aws.amazon.com/lambda/latest/dg/urls-invocation.html#urls-response-payload)
formats are the same as above.

Because we have our additional "gotcha", I wanted to test the case where the
`POST` method is disabled and so I've added an additional test using the 
command from `Valid JSON request`:

| Test                  | Status Code | Response Body             | `input` in lambda          |
| ---                   | ---         | ---                       | ---                        |
| Valid JSON request    | 200         | `{}`                      | The JSON formatted request |
| Invalid JSON request  | 200         | `{}`                      | The JSON formatted request |
| Invalid JSON response | 200         | `{`                       | The JSON formatted request |
| Exception thrown      | 502         | `Internal Server Error`   | The JSON formatted request |
| POST Method disabled  | 403         | HTML explaining the error | Nothing                    |



## API Gateway w/ HTTP API

HTTP APIs are API Gateway's less featureful option, which is reflected in it's
relatively simple setup:
- [Create your HTTP API](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop.html)
  - For **Integrations** select **lambda**
  - For **Lambda function** choose your lambda
- See [here](#custom-domain-setup) setting up a custom domain

The [request](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html#http-api-develop-integrations-lambda.proxy-format-structure)
and [response](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html#http-api-develop-integrations-lambda.v2)
formats seem to be identical to Function URLs, also similarly to Function URLs
it's worth noting that responses that don't match this format are assumed to be
a 200 response.

Here are my test results:

| Test                  | Status Code | Response Body                         | `input` in lambda          |
| ---                   | ---         | ---                                   | ---                        |
| Valid JSON request    | 200         | `{}`                                  | The JSON formatted request |
| Invalid JSON request  | 200         | `{}`                                  | The JSON formatted request |
| Invalid JSON response | 500         | `{"message":"Internal Server Error"}` | The JSON formatted request |
| Exception thrown      | 500         | `{"message":"Internal Server Error"}` | The JSON formatted request |



## API Gateway w/ REST API

Setting up a REST API was a tiny bit more involved:
- [Create your API REST API](https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-rest-new-console.html#getting-started-rest-new-console-create-api)
  - Choose **New API** instead of **Example API**
- [Create your Lambda Integration](https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-rest-new-console.html#getting-started-rest-new-console-create-integration)
  - Keep **Lambda Proxy Integration** turned off (that's the next section)
- See [here](#custom-domain-setup) setting up a custom domain

The request and response formats are a bit more fuzzily documented for this
option due to requests being configured using [Integration Requests](https://docs.aws.amazon.com/apigateway/latest/developerguide/integration-request-basic-setup.html)
and responses being configured using [Integration Responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-integration-settings-integration-response.html).
Meaning you can [transform](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-method-settings-execution-console.html)
the request and response in a variety of ways. By default the body is passed
through to the lambda directly and I've left things as the default for the
tests.

To test this setup I had to tweak two of the commands (while keeping the lambda
the same):
| Test                  | Command                                              |
| ---                   | ---                                                  |
| Invalid JSON response | `curl -v -XPOST --data '"invalid"' <url under test>` |
| Exception thrown      | `curl -v -XPOST --data '"error"'   <url under test>` |

Please note that a lot of the results of the tests this time can be configured
(as you'll see after the results). It's still worth understanding the default
behaviours though to know what you need to configure. I would suggest
re-running these tests (and others!) after making configuration changes to
see how these behaviours have really changed:

| Test                  | Status Code | Response Body                                               | `input` in lambda            |
| ---                   | ---         | ---                                                         | ---                          |
| Valid JSON request    | 200         | `{}`                                                        | `{}` (the input body)        |
| Invalid JSON request  | 400         | A JSON object with a `message` field explaining parse error | Nothing                      |
| Invalid JSON response | 200         | `{`                                                         | `"invalid"` (the input body) |
| Exception thrown      | 200         | A JSON object in [this format](https://docs.aws.amazon.com/apigateway/latest/developerguide/handle-errors-in-lambda-integration.html#handle-standard-errors-in-lambda-integration) showing the error thrown   | `"error"` (the input)   |

A couple things to note here:
1. If the request is not valid JSON, your function won't be called.
   I was not able to find a way around this in my testing, please let me know if I missed something.
2. Throwing an error gets you a 200 by default.
   The official way to handle this is to configure the **Lambda error regex**
   which is matched against the *errorMessage* property in the response (as
   noted [here](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-method-settings-execution-console.html)
   in the final *Note* box, search for *errorMessage*). Luckily exceptions are
   already formatted this way, but note that you can also return JSON in this
   format if you like.



## API Gateway w/ REST API & Lambda Proxy Integration

The setup is nearly identical to the above:
- [Create your API REST API](https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-rest-new-console.html#getting-started-rest-new-console-create-api)
  - Choose **New API** instead of **Example API**
- [Create your Lambda Integration](https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-rest-new-console.html#getting-started-rest-new-console-create-integration)
  - This time turn **Lambda Proxy Integration** on
- See [here](#custom-domain-setup) setting up a custom domain

The [request](https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-lambda-proxy-integrations.html#api-gateway-simple-proxy-for-lambda-input-format)
and [response](https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-lambda-proxy-integrations.html#api-gateway-simple-proxy-for-lambda-output-format)
formats are similar to the Function URL formats but with enough small
differences that it's worth you taking a look at them.

And here are my test results (using the original commands):
| Test                  | Status Code | Response Body                          | `input` in lambda          |
| ---                   | ---         | ---                                    | ---                        |
| Valid JSON request    | 200         | (an empty body)                        | The JSON formatted request |
| Invalid JSON request  | 200         | (an empty body)                        | The JSON formatted request |
| Invalid JSON response | 502         | `{"message": "Internal server error"}` | The JSON formatted request |
| Exception thrown      | 502         | `{"message": "Internal server error"}` | The JSON formatted request |



# Conclusion

There are many different options for calling an AWS Lambda via HTTP, and while
it's fairly obvious that each of them would have different setup instructions I
found that the variance in their behaviours was enough to trip me up many
times. Hopefully the above information will be useful to avoid the gotchas in
your chosen option the next time either of us wants to call a Lambda over HTTP.



<a id="custom-domain-setup"></a> 

#### Appendix: Custom Domains and API Gateway

Setting up a Custom Domain works the same way for all API Gateway options. To
limit repetition here are the setup instructions all in one place:
- [Create a Certificate](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains-prerequisites.html) if you don't already have one
- Setup a [Custom Domain](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-regional-api-custom-domain-create.html) in API Gateway
- [Add an A record to Route53](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-creating.html)
  - Use an alias to point to your Custom Domain
- In the Custom Domain [add an API Mapping](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-regional-api-custom-domain-create.html) to the stage of your API
