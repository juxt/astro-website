---
import { readFileSync, readdirSync, statSync } from 'fs'
import { join } from 'path'
import RadarChart from './RadarChart.astro'
import { RADAR_COLORS } from '../utils/radar-colors'

// Function to recursively find all markdown files in a directory
function findMarkdownFiles(dir: string): string[] {
  const files: string[] = []

  try {
    const items = readdirSync(dir)

    for (const item of items) {
      const fullPath = join(dir, item)
      const stat = statSync(fullPath)

      if (stat.isDirectory()) {
        files.push(...findMarkdownFiles(fullPath))
      } else if (item.endsWith('.mdx') || item.endsWith('.md')) {
        files.push(fullPath)
      }
    }
  } catch (error) {
    console.warn(`Could not read directory ${dir}:`, error)
  }

  return files
}

// Function to generate base URL from file path
function generateBaseUrl(filePath: string): string {
  const relativePath = filePath.replace(
    join(process.cwd(), 'src/pages/ai-radar/'),
    ''
  )
  const pathWithoutExt = relativePath.replace(/\.(mdx|md)$/, '')
  return `/ai-radar/${pathWithoutExt}`
}

// Simple slugify function
function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/(^-|-$)/g, '')
}

// Convert quadrant label to quadrant number (0,1,2,3 counting clockwise from bottom right)
function getQuadrantForSegment(quadrant: string): number {
  switch (quadrant) {
    case 'techniques':
      return 3 // Top Right
    case 'languages-frameworks':
      return 2 // Top Left
    case 'tools':
      return 1 // Bottom Left
    case 'platforms':
      return 0 // Bottom Right
    default:
      throw new Error(`Invalid quadrant: ${quadrant}`)
  }
}

// Convert ring label to ring number (0,1,2,3 starting from inside)
function getRingForAdoptionLevel(ring: string): number {
  switch (ring) {
    case 'adopt':
      return 0 // INNER
    case 'trial':
      return 1 // SECOND
    case 'assess':
      return 2 // THIRD
    case 'hold':
      return 3 // OUTER
    default:
      throw new Error(`Invalid ring: ${ring}`)
  }
}

// Convert move string to numeric value for Zalando radar
function getMovedValue(moved: string | number | undefined): number {
  if (typeof moved === 'number') return moved
  if (typeof moved === 'string') {
    switch (moved.toLowerCase()) {
      case 'up':
        return 1
      case 'down':
        return -1
      case 'new':
        return 2
      default:
        return 0
    }
  }
  return 0 // Default to no change
}

// Infer quadrant from file path by reading parent article
function inferQuadrantFromFilePath(filePath: string): string {
  const pathParts = filePath.split('/')
  const segmentIndex = pathParts.findIndex((part) =>
    ['techniques', 'languages-frameworks', 'tools', 'platforms'].includes(part)
  )

  if (segmentIndex === -1) return 'techniques' // fallback

  const segment = pathParts[segmentIndex]

  // Read the parent article to get the title
  const parentArticlePath = join(
    process.cwd(),
    'src/pages/ai-radar',
    segment,
    'index.mdx'
  )

  try {
    const parentContent = readFileSync(parentArticlePath, 'utf-8')
    const titleMatch = parentContent.match(/title:\s*['"]([^'"]+)['"]/)

    if (titleMatch) {
      const title = titleMatch[1]

      // Map title to quadrant
      if (title.includes('Techniques')) return 'techniques'
      if (title.includes('Languages') || title.includes('Frameworks'))
        return 'languages-frameworks'
      if (title.includes('Tools')) return 'tools'
      if (title.includes('Platforms')) return 'platforms'
    }
  } catch (error) {
    console.warn(`Failed to read parent article for ${filePath}:`, error)
  }

  // Fallback to segment name
  return segment
}

// Infer ring from file path
function inferRingFromFilePath(filePath: string): string {
  const pathParts = filePath.split('/')

  for (const part of pathParts) {
    if (['adopt', 'trial', 'assess', 'hold'].includes(part)) {
      return part
    }
    // Check for ring with file extension
    if (
      part.startsWith('adopt.') ||
      part.startsWith('trial.') ||
      part.startsWith('assess.') ||
      part.startsWith('hold.')
    ) {
      return part.split('.')[0]
    }
  }

  return 'assess' // fallback
}

// Parse radar entries from markdown content
function parseRadarFromMarkdown(
  content: string,
  baseUrl: string,
  filePath: string
) {
  const entries: any[] = []

  // Find all divs with data-radar attribute and data-meta attributes
  const metaDivRegex = /<div\s+data-radar\s+data-meta='([^']+)'\s*\/>/g
  let metaMatch

  // Store all matches with their positions to sort them by order of appearance
  const matches = []

  while ((metaMatch = metaDivRegex.exec(content)) !== null) {
    matches.push({ match: metaMatch, index: metaMatch.index })
  }

  // Sort matches by their position in the document to maintain order
  matches.sort((a, b) => a.index - b.index)

  // Process matches in order of appearance
  for (const { match } of matches) {
    const metaString = match[1]
    const metaIndex = match.index

    // Parse metadata
    let sectionMetadata: Record<string, any> = {}
    try {
      const meta = JSON.parse(metaString)
      sectionMetadata = meta
    } catch (e) {
      console.warn('Failed to parse metadata:', metaString)
      continue
    }

    // Find the next heading after this metadata div
    const contentAfterMeta = content.substring(metaIndex)
    const headingMatch = contentAfterMeta.match(/\n## (.+)$/m)

    if (!headingMatch) {
      console.warn('No heading found after metadata div')
      continue
    }

    const sectionName = headingMatch[1].trim()

    // Skip the main title section if it exists
    if (
      sectionName.toLowerCase().includes('adopt') ||
      sectionName.toLowerCase().includes('trial') ||
      sectionName.toLowerCase().includes('assess') ||
      sectionName.toLowerCase().includes('hold')
    ) {
      continue
    }

    // Infer quadrant and ring from file structure
    const quadrant = inferQuadrantFromFilePath(filePath)
    const ring = inferRingFromFilePath(filePath)

    // Convert to radar format
    const entry = {
      label: sectionMetadata.label || sectionName,
      quadrant: getQuadrantForSegment(quadrant),
      ring: getRingForAdoptionLevel(ring),
      moved: getMovedValue(sectionMetadata.moved), // Map string values to numeric
      link: `${baseUrl}#${slugify(sectionName)}`,
      active: true
    }

    entries.push(entry)
  }

  return entries
}

// Main logic to collect all radar data at build time
const aiRadarDir = join(process.cwd(), 'src/pages/ai-radar')
const allMarkdownFiles = findMarkdownFiles(aiRadarDir).sort() // Sort files for predictable order
const allEntries: any[] = []

console.log(
  `Found ${allMarkdownFiles.length} markdown files in ai-radar directory`
)

// Debug: Show which files we're processing
allMarkdownFiles.forEach((file) => {})

for (const filePath of allMarkdownFiles) {
  try {
    // Read the file content
    const content = readFileSync(filePath, 'utf-8')

    // Generate base URL for this file
    const baseUrl = generateBaseUrl(filePath)

    // Parse the markdown content to extract radar entries
    const entries = parseRadarFromMarkdown(content, baseUrl, filePath)

    if (entries.length > 0) {
      allEntries.push(...entries)
    }
  } catch (error) {
    console.warn(`Failed to process file ${filePath}:`, error)
  }
}

console.log(`Total radar entries collected: ${allEntries.length}`)

// Prepare AI radar data
const radarData = {
  quadrants: [
    {
      name: 'Platforms',
      link: '/ai-radar/platforms',
      color: RADAR_COLORS.platforms
    },
    { name: 'Tools', link: '/ai-radar/tools', color: RADAR_COLORS.tools },
    {
      name: 'Languages & Frameworks',
      link: '/ai-radar/languages-frameworks',
      color: RADAR_COLORS.languagesFrameworks
    },
    {
      name: 'Techniques',
      link: '/ai-radar/techniques',
      color: RADAR_COLORS.techniques
    }
  ],
  rings: [
    { name: 'ADOPT' },
    { name: 'TRIAL' },
    { name: 'ASSESS' },
    { name: 'HOLD' }
  ],
  entries: allEntries
}
---

<div class='radar-container'>
  <!-- Quadrant Cards for Small Devices -->
  <div class='lg:hidden'>
    <div class='grid grid-cols-1 md:grid-cols-2 gap-4 p-4'>
      {
        radarData.quadrants.map((quadrant, index) => (
          <a
            href={quadrant.link}
            class='min-h-[120px] flex items-center justify-center bg-gradient-to-br from-slate-50 to-slate-100 dark:from-slate-800 dark:to-slate-700 p-6 rounded-lg shadow-lg hover:shadow-xl transition-all duration-300 transform hover:scale-105 border border-slate-200 dark:border-slate-600 hover:from-slate-600 hover:to-slate-700 group'
          >
            <div class='text-center flex flex-col items-center justify-center gap-1'>
              <h3 class='text-2xl font-semibold text-gray-800 dark:text-gray-200 group-hover:text-white'>
                {quadrant.name}
              </h3>
              <div class='text-sm text-gray-600 dark:text-gray-400 group-hover:text-white'>
                Click to explore
              </div>
            </div>
          </a>
        ))
      }
    </div>
  </div>

  <!-- Radar Chart for Large Devices -->
  <div class='hidden lg:block'>
    <RadarChart data={radarData} linksInNewTabs={false} />
  </div>
</div>
